const { ApplicationCommandOptionType, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const db = require('../mongoDB');

module.exports = {
  name: "playlist",
  description: "‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°",
  options: [
    {
      name: "create",
      description: "‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°",
      type: ApplicationCommandOptionType.Subcommand,
      options: [
        {
          name: "name",
          description: "‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì",
          type: ApplicationCommandOptionType.String,
          required: true
        },
        {
          name: "public",
          description: "‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏≤‡∏ò‡∏≤‡∏£‡∏ì‡∏∞‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏ó‡πá‡∏à True or false",
          type: ApplicationCommandOptionType.Boolean,
          required: true
        }
      ]
    },
    {
      name: "delete",
      description: "‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì?",
      type: ApplicationCommandOptionType.Subcommand,
      options: [
        {
          name: "name",
          description: "‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏•‡∏ö",
          type: ApplicationCommandOptionType.String,
          required: true
        }
      ]
    },
    {
      name: "add-music",
      description: "‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏•‡∏á‡∏•‡∏á‡πÉ‡∏ô‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡πÑ‡∏î‡πâ",
      type: ApplicationCommandOptionType.Subcommand,
      options: [
        {
          name: "playlist-name",
          description: "‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°",
          type: ApplicationCommandOptionType.String,
          required: true
        },
        {
          name: "name",
          description: "‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏¥‡∏á‡∏Ñ‡πå‡πÄ‡∏û‡∏•‡∏á",
          type: ApplicationCommandOptionType.String,
          required: true
        }
      ]
    },
    {
      name: "delete-music",
      description: "‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡πÄ‡∏û‡∏•‡∏á‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡πÑ‡∏î‡πâ",
      type: ApplicationCommandOptionType.Subcommand,
      options: [
        {
          name: "playlist-name",
          description: "‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°",
          type: ApplicationCommandOptionType.String,
          required: true
        },
        {
          name: "name",
          description: "‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á",
          type: ApplicationCommandOptionType.String,
          required: true
        }
      ]
    },
    {
      name: "list",
      description: "‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏î‡∏π‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏ô‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°",
      type: ApplicationCommandOptionType.Subcommand,
      options: [
        {
          name: "name",
          description: "‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°",
          type: ApplicationCommandOptionType.String,
          required: true
        }
      ]
    },
    {
      name: "lists",
      description: "‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏î‡∏π‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì",
      type: ApplicationCommandOptionType.Subcommand,
      options: []
    },
    {
      name: "top",
      description: "‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏¢‡∏≠‡∏î‡∏ô‡∏¥‡∏¢‡∏°",
      type: ApplicationCommandOptionType.Subcommand,
      options: []
    }
  ],
  permissions: "0x0000000000000800",
  run: async (client, interaction) => {
    try {
      let stp = interaction.options.getSubcommand()
      if (stp === "create") {
        let name = interaction.options.getString('name')
        let public = interaction.options.getBoolean('public')
        if (!name) return interaction.reply({ content: '‚ö†Ô∏è ‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á!', ephemeral: true }).catch(e => { })

        const userplaylist = await db.playlist.findOne({ userID: interaction.user.id })

        const playlist = await db.playlist.find().catch(e => { })
        if (playlist?.length > 0) {
          for (let i = 0; i < playlist.length; i++) {
            if (playlist[i]?.playlist?.filter(p => p.name === name)?.length > 0) {
              return interaction.reply({ content: '‚ö†Ô∏è ‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏≠‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß!', ephemeral: true }).catch(e => { })
            }
          }
        }

        if (userplaylist?.playlist?.length >= client.config.playlistSettings.maxPlaylist) return interaction.reply({ content: 'üö´ ‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏á‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°', ephemeral: true }).catch(e => { })

        const creatingAlbumEmbed = new EmbedBuilder()
          .setColor('#0099ff')
          .setTitle('Creating Album')
          .setDescription(`Hey <@${interaction.member.id}>, ‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô! üé∏`)
          .setTimestamp();

        // Replying with both content and embed
        await interaction.reply({
          content: '',
          embeds: [creatingAlbumEmbed]
        }).catch(e => {
          console.error('Error sending message:', e);
        });

        await db.playlist.updateOne({ userID: interaction.user.id }, {
          $push: {
            playlist: {
              name: name,
              author: interaction.user.id,
              authorTag: interaction.user.tag,
              public: public,
              plays: 0,
              createdTime: Date.now()
            }
          }
        }, { upsert: true }).catch(e => { })

        const albumCreatedEmbed = new EmbedBuilder()
  .setColor('#00ff00')
          .setAuthor({
            name: '‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß',
            iconURL: 'https://cdn.discordapp.com/attachments/1213421081226903552/1215554404527116288/7762-verified-blue.gif',
            url: 'https://discord.gg/FUEHs7RCqz'
          })
  .setDescription(`Hey <@${interaction.member.id}>, ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß! üéâ`)
  .setTimestamp();

// Editing the reply with both content and embed
await interaction.editReply({
  content: '',
  embeds: [albumCreatedEmbed]
}).catch(e => {
  console.error('Error editing reply:', e);
});
      }

      if (stp === "delete") {
        let name = interaction.options.getString('name')
        if (!name) return interaction.reply({ content: '‚ö†Ô∏è ‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á!', ephemeral: true }).catch(e => { })

        const playlist = await db.playlist.findOne({ userID: interaction.user.id }).catch(e => { })
        if (!playlist?.playlist?.filter(p => p.name === name).length > 0) return interaction.reply({ content: '‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°', ephemeral: true }).catch(e => { })

        const music_filter = playlist?.musics?.filter(m => m.playlist_name === name)
        if (music_filter?.length > 0){
          await db.playlist.updateOne({ userID: interaction.user.id }, {
            $pull: {
              musics: {
                playlist_name: name
              }
            }
          }).catch(e => { })
        }

       const deletingAlbumEmbed = new EmbedBuilder()
          .setColor('#0099ff')
          .setTitle('Deleting Album')
          .setDescription(`Hey <@${interaction.member.id}>, ‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ñ‡∏π‡∏Å‡∏•‡∏ö üé∏`)
          .setTimestamp();

        // Replying with both content and embed
        await interaction.reply({
          content: '',
          embeds: [deletingAlbumEmbed]
        }).catch(e => {
          console.error('Error sending message:', e);
        });

        await db.playlist.updateOne({ userID: interaction.user.id }, {
          $pull: {
            playlist: {
              name: name
            }
          }
        }, { upsert: true }).catch(e => { })

         const albumDeleteEmbed = new EmbedBuilder()
  .setColor('#00ff00')
          .setAuthor({
            name: '‡∏•‡∏ö‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
            iconURL: 'https://cdn.discordapp.com/attachments/1213421081226903552/1215554404527116288/7762-verified-blue.gif',
            url: 'https://discord.gg/FUEHs7RCqz'
          })
  .setDescription(`Hey <@${interaction.member.id}>, ‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß! ‚ú®`)
  .setTimestamp();

// Editing the reply with both content and embed
await interaction.editReply({
  content: '',
  embeds: [albumDeleteEmbed]
}).catch(e => {
  console.error('Error editing reply:', e);
});
      }

      if (stp === "add-music") {
        let name = interaction.options.getString('name')
        if (!name) return interaction.reply({ content: '‚ö†Ô∏è ‡∏Å‡∏£‡∏≠‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤', ephemeral: true }).catch(e => { })
        let playlist_name = interaction.options.getString('playlist-name')
        if (!playlist_name) return interaction.reply({ content: '‚ö†Ô∏è ‡∏õ‡πâ‡∏≠‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏•‡∏á', ephemeral: true }).catch(e => { })

        const playlist = await db.playlist.findOne({ userID: interaction.user.id }).catch(e => { })
        if (!playlist?.playlist?.filter(p => p.name === playlist_name).length > 0) return interaction.reply({ content: '‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏•‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏•‡πâ‡∏ß!', ephemeral: true }).catch(e => { })

        let max_music = client.config.playlistSettings.maxMusic
        if (playlist?.musics?.filter(m => m.playlist_name === playlist_name).length > max_music) return interaction.reply({ content: "‡∏ñ‡∏∂‡∏á‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÄ‡∏û‡∏•‡∏á‡∏Ç‡∏≠‡∏á‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡πÅ‡∏•‡πâ‡∏ß".replace("{max_music}", max_music), ephemeral: true }).catch(e => { })
        let res 
        try{
          res = await client.player.search(name, {
            member: interaction.member,
            textChannel: interaction.channel,
            interaction
          })
        } catch (e) {
          return interaction.reply({ content: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÑ‡∏î‡πâ ‚ùå', ephemeral: true }).catch(e => { })
        }
        if (!res || !res.length || !res.length > 1) return interaction.reply({ content: `‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÑ‡∏î‡πâ ‚ùå `, ephemeral: true }).catch(e => { })
        const loadingembed = new EmbedBuilder()
        .setColor('#0099ff')
       .setAuthor({
          name: '‡πÄ‡∏û‡∏•‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏ô‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì',
          iconURL: 'https://cdn.discordapp.com/attachments/1213421081226903552/1213430944007061574/6943_Verified.gif',
          url: 'https://discord.gg/FUEHs7RCqz'
        })
        .setDescription(`Hey <@${interaction.member.id}>, ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏•‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß! ‚ú®`)
        .setFooter({ text: 'YouTube - RTX GAMING' })
        await interaction.reply({
  content: '',
  embeds: [ loadingembed ] 
}).catch(e => {
  console.error('Error sending message:', e);
});

        const music_filter = playlist?.musics?.filter(m => m.playlist_name === playlist_name && m.music_name === res[0]?.name)
        if (music_filter?.length > 0) return interaction.editReply({ content: ' ‚ùå ‡πÄ‡∏û‡∏•‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡πÅ‡∏•‡πâ‡∏ß', ephemeral: true }).catch(e => { })

        await db.playlist.updateOne({ userID: interaction.user.id }, {
          $push: {
            musics: {
              playlist_name: playlist_name,
              music_name: res[0]?.name,
              music_url: res[0]?.url, 
              saveTime: Date.now()
            }
          }
        }, { upsert: true }).catch(e => { })

        await interaction.editReply({ content: `<@${interaction.member.id}>, \`${res[0]?.name}\` ` }).catch(e => { })

      }

      if (stp === "delete-music") {
        let name = interaction.options.getString('name')
        if (!name) return interaction.reply({ content: '‚ö†Ô∏è ‡∏õ‡πâ‡∏≠‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤!', ephemeral: true }).catch(e => { })
        let playlist_name = interaction.options.getString('playlist-name')
        if (!playlist_name) return interaction.reply({ content: '‚ö†Ô∏è ‡∏õ‡πâ‡∏≠‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏•‡∏ö‡πÄ‡∏û‡∏•‡∏á!', ephemeral: true }).catch(e => { })

        const playlist = await db.playlist.findOne({ userID: interaction.user.id }).catch(e => { })
        if (!playlist?.playlist?.filter(p => p.name === playlist_name).length > 0) return interaction.reply({ content: '‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°!', ephemeral: true }).catch(e => { })

        const music_filter = playlist?.musics?.filter(m => m.playlist_name === playlist_name && m.music_name === name)
        if (!music_filter?.length > 0) return interaction.reply({ content: `‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏û‡∏•‡∏á!`, ephemeral: true }).catch(e => { })

         const deletingSongEmbed = new EmbedBuilder()
          .setColor('#0099ff')
          .setTitle('Removing Song')
          .setDescription(`Hey <@${interaction.member.id}>, your Song is being Removed!`)
          .setTimestamp();

        // Replying with both content and embed
        await interaction.reply({
          content: '',
          embeds: [deletingSongEmbed]
        }).catch(e => {
          console.error('Error sending message:', e);
        });

        await db.playlist.updateOne({ userID: interaction.user.id }, {
          $pull: {
            musics: {
              playlist_name: playlist_name,
              music_name: name
            }
          }
        }, { upsert: true }).catch(e => { })

         const songDeleteEmbed = new EmbedBuilder()
  .setColor('#00ff00')
          .setAuthor({
            name: '‡∏•‡∏ö‡πÄ‡∏û‡∏•‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß',
            iconURL: 'https://cdn.discordapp.com/attachments/1213421081226903552/1215554404527116288/7762-verified-blue.gif',
            url: 'https://discord.gg/FUEHs7RCqz'
          })
  .setDescription(`Hey <@${interaction.member.id}>, ‡πÄ‡∏û‡∏•‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡∏•‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß! ‚ú®`)
  .setTimestamp();

// Editing the reply with both content and embed
await interaction.editReply({
  content: '',
  embeds: [songDeleteEmbed]
}).catch(e => {
  console.error('Error editing reply:', e);
});
      }

      if (stp === "list") {
        let name = interaction.options.getString('name')
        if (!name) return interaction.reply({ content: '‚ö†Ô∏è ‡∏õ‡πâ‡∏≠‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤!', ephemeral: true }).catch(e => { })

        let trackl

        const playlist = await db.playlist.find().catch(e => { })
        if (!playlist?.length > 0) return interaction.reply({ content: `üö´ ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°!`, ephemeral: true }).catch(e => { })

        let arr = 0
        for (let i = 0; i < playlist.length; i++) {
          if (playlist[i]?.playlist?.filter(p => p.name === name)?.length > 0) {

            let playlist_owner_filter = playlist[i].playlist.filter(p => p.name === name)[0].author
            let playlist_public_filter = playlist[i].playlist.filter(p => p.name === name)[0].public

            if (playlist_owner_filter !== interaction.member.id) {
              if (playlist_public_filter === false) {
                return interaction.reply({ content: 'üö´ ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ!', ephemeral: true }).catch(e => { })
              }
            }

            trackl = await playlist[i]?.musics?.filter(m => m.playlist_name === name)
            if (!trackl?.length > 0) return interaction.reply({ content: '‚ùå ‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏ô‡∏µ‡πâ‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏î‡∏Å‡πá‡πÑ‡∏î‡πâ‡∏•‡∏á‡πÑ‡∏õ!', ephemeral: true }).catch(e => { })

          } else {
            arr++
            if (arr === playlist.length) {
              return interaction.reply({ content: '‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°', ephemeral: true }).catch(e => { })
            }
          }
        }

        const backId = "emojiBack"
        const forwardId = "emojiForward"
        const backButton = new ButtonBuilder({
          style: ButtonStyle.Secondary,
          emoji: "‚óÄÔ∏è",
          customId: backId
        });

        const deleteButton = new ButtonBuilder({
          style: ButtonStyle.Secondary,
          emoji: "üö´",
          customId: "close"
        });

        const forwardButton = new ButtonBuilder({
          style: ButtonStyle.Secondary,
          emoji: "‚ñ∂Ô∏è",
          customId: forwardId
        });


        let ka√ßtane = 8
        let page = 1
        let a = trackl.length / ka√ßtane

        const generateEmbed = async (start) => {
          let sayƒ± = page === 1 ? 1 : page * ka√ßtane - ka√ßtane + 1
          const current = trackl.slice(start, start + ka√ßtane)
          if (!current || !current?.length > 0) return interaction.reply({ content: '‚ùå ‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤, ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏•‡∏á‡πÉ‡∏î ‡πÜ ‡∏•‡∏á‡πÑ‡∏õ!', ephemeral: true }).catch(e => { })
          return new EmbedBuilder()
           .setAuthor({
          name: '‡πÄ‡∏û‡∏•‡∏á‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°',
          iconURL: 'https://cdn.discordapp.com/attachments/1213421081226903552/1213422313035407360/8218-alert.gif',
          url: 'https://discord.gg/FUEHs7RCqz'
        })
            .setThumbnail(interaction.user.displayAvatarURL({ size: 2048, dynamic: true }))
            .setColor(client.config.embedColor) 
            .setDescription(`\n${current.map(data =>
              `\n\`${sayƒ±++}\` | [${data.music_name}](${data.music_url}) - <t:${Math.floor(data.saveTime / 1000) }:R>`
            ) }`)
            .setFooter({ text: `Section ${page}/${Math.floor(a+1) }` })
        }

        const canFitOnOnePage = trackl.length <= ka√ßtane

        await interaction.reply({
          embeds: [await generateEmbed(0)],
          components: canFitOnOnePage
            ? []
            : [new ActionRowBuilder({ components: [deleteButton, forwardButton] })],
          fetchReply: true
        }).then(async Message => {
          const filter = i => i.user.id === interaction.user.id
          const collector = Message.createMessageComponentCollector({ filter, time: 65000 });


          let currentIndex = 0
          collector.on("collect", async (button) => {
            if (button.customId === "close") {
              collector.stop()
              return button.reply({ content: `‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å ‚ùå`, ephemeral: true }).catch(e => { })
            } else {

              if (button.customId === backId) {
                page--
              }
              if (button.customId === forwardId) {
                page++
              }

              button.customId === backId
                ? (currentIndex -= ka√ßtane)
                : (currentIndex += ka√ßtane)

              await interaction.editReply({
                embeds: [await generateEmbed(currentIndex)],
                components: [
                  new ActionRowBuilder({
                    components: [
                      ...(currentIndex ? [backButton] : []),
                      deleteButton,
                      ...(currentIndex + ka√ßtane < trackl.length ? [forwardButton] : []),
                    ],
                  }),
                ],
              }).catch(e => { })
              await button.deferUpdate().catch(e => {})
            }
          })

          collector.on("end", async (button) => {
            button = new ActionRowBuilder().addComponents(
              new ButtonBuilder()
                .setStyle(ButtonStyle.Secondary)
                .setEmoji("‚óÄÔ∏è")
                .setCustomId(backId)
                .setDisabled(true),
              new ButtonBuilder()
                .setStyle(ButtonStyle.Secondary)
                .setEmoji("üö´")
                .setCustomId("close")
                .setDisabled(true),
              new ButtonBuilder()
                .setStyle(ButtonStyle.Secondary)
                .setEmoji("‚ñ∂Ô∏è")
                .setCustomId(forwardId)
                .setDisabled(true))

            const embed = new EmbedBuilder()
              .setTitle(`${name}`)
              .setThumbnail(interaction.user.displayAvatarURL({ size: 2048, dynamic: true }))
              .setColor(client.config.embedColor)
              .setDescription('‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤ ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á!'.replace("{name}", name))
              .setFooter({ text: 'YouTube - RTX GAMING' })
            return interaction.editReply({ embeds: [embed], components: [button] }).catch(e => { })

          })
        }).catch(e => { })

      }

      if (stp === "lists") {
        const playlist = await db?.playlist?.findOne({ userID: interaction.user.id }).catch(e => { })
        if (!playlist?.playlist?.length > 0) return interaction.reply({ content: `‚ö†Ô∏è ‡∏Ñ‡∏∏‡∏ì‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°`, ephemeral: true }).catch(e => { })

        let number = 1
        const embed = new EmbedBuilder()
          .setAuthor({
            name: '‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì',
            iconURL: 'https://cdn.discordapp.com/attachments/1213421081226903552/1213422313035407360/8218-alert.gif',
            url: 'https://discord.gg/FUEHs7RCqz'
          })
          .setColor(client.config.embedColor)
          .setDescription(`\n${playlist?.playlist?.map(data =>
            `\n**${number++} |** \`${data.name}\` - **${playlist?.musics?.filter(m => m.playlist_name === data.name)?.length || 0}** plays (<t:${Math.floor(data.createdTime / 1000) }:R>)`
          ) }`)
          .setFooter({ text: 'YouTube - RTX GAMING' })
        return interaction.reply({ embeds: [embed] }).catch(e => { }) 

      }

      if (stp === "top") {
        let playlists = await db?.playlist?.find().catch(e => { })
        if (!playlists?.length > 0) return interaction.reply({ content: '‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå ‚ùå', ephemeral: true }).catch(e => { })

        let trackl = []
        playlists.map(async data => {
          data.playlist.filter(d => d.public === true).map(async d => {
            let filter = data.musics.filter(m => m.playlist_name === d.name)
            if (filter.length > 0) {
              trackl.push(d)
            }
          })
        })

        trackl = trackl.filter(a => a.plays > 0) 

        if (!trackl?.length > 0) return interaction.reply({ content: '‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå ‚ùå', ephemeral: true }).catch(e => { })

        trackl = trackl.sort((a, b) => b.plays - a.plays)

        const backId = "emojiBack"
        const forwardId = "emojiForward"
        const backButton = new ButtonBuilder({
          style: ButtonStyle.Secondary,
          emoji: "‚óÄÔ∏è",
          customId: backId
        });

        const deleteButton = new ButtonBuilder({
          style: ButtonStyle.Secondary,
          emoji: "üö´",
          customId: "close"
        });

        const forwardButton = new ButtonBuilder({
          style: ButtonStyle.Secondary,
          emoji: "‚ñ∂Ô∏è",
          customId: forwardId
        });


        let ka√ßtane = 8
        let page = 1
        let a = trackl.length / ka√ßtane

        const generateEmbed = async (start) => {
          let sayƒ± = page === 1 ? 1 : page * ka√ßtane - ka√ßtane + 1
          const current = trackl.slice(start, start + ka√ßtane)
          if (!current || !current?.length > 0) return interaction.reply({ content: `‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏° ‚ùå`, ephemeral: true }).catch(e => { })
          return new EmbedBuilder()
            .setAuthor({
              name: '‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏¢‡∏≠‡∏î‡∏ô‡∏¥‡∏¢‡∏°',
              iconURL: 'https://cdn.discordapp.com/attachments/1213421081226903552/1213422313035407360/8218-alert.gif',
              url: 'https://discord.gg/FUEHs7RCqz'
            })
            .setThumbnail(interaction.user.displayAvatarURL({ size: 2048, dynamic: true }))
            .setColor(client.config.embedColor)
            .setDescription(`\n${current.map(data =>
              `\n**${sayƒ±++} |** \`${data.name}\` By. \`${data.authorTag}\` - **${data.plays}** "plays" (<t:${Math.floor(data.createdTime / 1000) }:R>)`
            ) }`)
            .setFooter({ text: `‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà ${page}/${Math.floor(a+1) }` })
        }

        const canFitOnOnePage = trackl.length <= ka√ßtane

        await interaction.reply({
          embeds: [await generateEmbed(0)],
          components: canFitOnOnePage
            ? []
            : [new ActionRowBuilder({ components: [deleteButton, forwardButton] })],
          fetchReply: true
        }).then(async Message => {
          const filter = i => i.user.id === interaction.user.id
          const collector = Message.createMessageComponentCollector({ filter, time: 120000 });


          let currentIndex = 0
          collector.on("collect", async (button) => {
            if (button.customId === "close") {
              collector.stop()
              return button.reply({ content: `‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏´‡∏¢‡∏∏‡∏î‡∏•‡∏á ‚úÖ`, ephemeral: true }).catch(e => { })
            } else {

              if (button.customId === backId) {
                page--
              }
              if (button.customId === forwardId) {
                page++
              }

              button.customId === backId
                ? (currentIndex -= ka√ßtane)
                : (currentIndex += ka√ßtane)

              await interaction.editReply({
                embeds: [await generateEmbed(currentIndex)],
                components: [
                  new ActionRowBuilder({
                    components: [
                      ...(currentIndex ? [backButton] : []),
                      deleteButton,
                      ...(currentIndex + ka√ßtane < trackl.length ? [forwardButton] : []),
                    ],
                  }),
                ],
              }).catch(e => { })
              await button.deferUpdate().catch(e => {})
            }
          })

          collector.on("end", async (button) => {
            button = new ActionRowBuilder().addComponents(
              new ButtonBuilder()
                .setStyle(ButtonStyle.Secondary)
                .setEmoji("‚óÄÔ∏è")
                .setCustomId(backId)
                .setDisabled(true),
              new ButtonBuilder()
                .setStyle(ButtonStyle.Secondary)
                .setEmoji("üö´")
                .setCustomId("close")
                .setDisabled(true),
              new ButtonBuilder()
                .setStyle(ButtonStyle.Secondary)
                .setEmoji("‚ñ∂Ô∏è")
                .setCustomId(forwardId)
                .setDisabled(true))

            const embed = new EmbedBuilder()
              .setAuthor({
          name: '‡∏≠‡∏±‡∏•‡∏ö‡∏±‡πâ‡∏°‡∏¢‡∏≠‡∏î‡∏ô‡∏¥‡∏¢‡∏°',
          iconURL: 'https://cdn.discordapp.com/attachments/1213421081226903552/1213422313035407360/8218-alert.gif',
          url: 'https://discord.gg/FUEHs7RCqz'
        })
              .setThumbnail(interaction.user.displayAvatarURL({ size: 2048, dynamic: true }))
              .setColor(client.config.embedColor)
              .setDescription('‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤!')
              .setFooter({ text: 'YouTube - RTX GAMING' })
            return interaction.editReply({ embeds: [embed], components: [button] }).catch(e => { })

          })
        }).catch(e => { })

      }
    } catch (e) {
      console.error(e);
      interaction.reply({ content: 'An error occurred while executing this command!', ephemeral: true }).catch(e => { })
    }
  }
}